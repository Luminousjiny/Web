# 📑 HDFS(Hadoop Distributed File System)

- 클러스터에서 실행되는 매우 큰 파일을 처리하도록 설계된 파일 시스템
- 한번 쓰고 여러번 읽는 것이 목적
- 저사양의 서버를 이용하여 스토리지 구성 가능
- 자바기반 파일 시스템 → JVM에서 동작
---   
## 🖍 안전성을 위한 전략

- **장애복구** : 데이터 중복저장
- **데이터 무결성(일관성)** : 한번 저장한 데이터는 read ONLY
---   
## 🖍 HDFS 아키텍처

### ☑ **블록구조** 파일 시스템

- 대용량 파일을 블록으로 나누어 관리
- 블록크기 기본적 64MB
- 설정을 통해 변경 가능
- 장점 : 디스크 시트타임 감소, 메타데이터 크기 감소 ( 메타데이터는 네임노드의 힙 메모리에 저장)

![image](https://user-images.githubusercontent.com/72757829/107148805-8c04c380-6998-11eb-926a-fcbc250c0c06.png)

### ☑ 마스터-슬레이브(Master-Slave) 구조

✔ **네임노드(관리자)** 

- 마스터 서버 역할
- 파일 시스템의 전반적인 부분
- 네임노드가 고장나면  전체 시스템 작동 X

✔ **데이터 노드(작업자)**

- 주로 파일 저장, 분산처리와 같이 실제적 일을 수행

### ☑ NN(네임노드)의 역할

1. **메타데이터 관리**
    - 메타데이터 = 파일시스템 이미지 + 파일에 대한 블록매핑 정보 → 빠른 파일 처리를 위해 메모리 관리
2. **데이터 노드 감시**
    - 데이터 노드는 네임노드에게 하트비트 메세지 주기적 전송 → 수신이 없다면 장애발생으로 간주
3. **클라이언트 요청 처리**
    - 클라이언트는 HDFS에 파일 IO를 수행할 때 NN의 허가를 받음 → 유효성 검사

---   
## 🖍 복제본 배치 전략
![image](https://user-images.githubusercontent.com/72757829/107201079-dc812d00-6a3b-11eb-9837-dc1795a7c5bc.png)   
```
첫 복제(임의 랙) → 두번째 복제(첫번째와 다른 랙) → 세번째 복제(두번째와 같은 랙, 다른 노드) → 이후(클러스터에서 무작위 선택
```   
```
→ **신뢰성**과 **대역폭** 사용은 **트레이드 오프** 관계
→ 균형의 조화
```   

> - 블록을 두 랙에 저장 : 신뢰성
> - 쓰기 대역폭 : 통과하는 네트워크 스위치 개수 축소
> - 읽기 성능 : 두 랙에서 가까운 랙 선택

---   
## 🖍 보조 네임 노드

☑ **역할**
- 주 시스템에 문제가 생겼을 때 주 시스템 기능 대체 역할
- 주 네임노드가 유지하는 **editslog 파일이 무한정 커지는 것을 막아줌**

✔ **fsimage 파일**

- 네임노드는 자신의 파일시스템의 메타데이터 정보를 유지히야함
- 메타메이터는 메모리에서 관리 → 빠른 처리 목적
- 메모리에 적재된 데이터는 손실위험이 높음 → fsimage 파일로 만들어 로컬 파일시스템에 저장
- fsimage는 변경 정보를 반영하여 주기적으로 갱신

✔ **editslog 파일**

- HDFS에서 발생하는 모든 변경이력 저장

> old fsimage + editslog = new fsimage

### 👀 네임노드가 파일 시스템 관리하는 방법
```text
1. 네임노드가 시작되면 fsimage를 메모리에 로딩
2. 메모리에 로딩된 fsimage에 editslog에 기록된 내용 병합
3. editslog 초기화
4. 데이터 노드가 전송한 메시지 통해 블록 저장 현황 파악
```   

> editslog파일은 용향 제한 X ... 크기가 너무 크면 2번 단계에 엄청난 시간 소요 ——> **보조네임노드의 필요**    
![image](https://user-images.githubusercontent.com/72757829/107201385-413c8780-6a3c-11eb-9f81-7ba927cec415.png)
